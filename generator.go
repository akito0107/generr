package generr

import (
	"io"

	"fmt"
	"go/ast"
	"go/format"
	"go/token"

	"strconv"

	"github.com/iancoleman/strcase"
	"github.com/pkg/errors"
)

type Generator struct {
	pkgName string
	f       *ast.File
	ts      *ast.TypeSpec
}

func NewGenerator(pkgName string, ts *ast.TypeSpec) *Generator {
	return &Generator{
		pkgName: pkgName,
		f:       &ast.File{},
		ts:      ts,
	}
}

func (g *Generator) Generate() error {
	g.AppendPackage()
	return nil
}

func (g *Generator) AppendPackage() {
	g.f.Name = &ast.Ident{
		Name: g.pkgName,
	}
}

func (g *Generator) AppendCheckFunction() error {
	d, err := appendCheckFunction(g.ts)
	if err != nil {
		return err
	}
	g.f.Decls = append(g.f.Decls, d...)
	return nil
}

func (g *Generator) AppendErrorImplementation() error {
	d, err := appendErrorImplementation(g.ts)
	if err != nil {
		return err
	}
	g.f.Decls = append(g.f.Decls, d...)
	return nil
}

func (g *Generator) Out(w io.Writer, filename string) error {
	fmt.Fprintf(w, "// Code generated by \"generr\"; DO NOT EDIT.\n")

	format.Node(w, token.NewFileSet(), g.f)
	return nil
}

func appendCheckFunction(ts *ast.TypeSpec) ([]ast.Decl, error) {
	it, ok := ts.Type.(*ast.InterfaceType)
	if !ok {
		return nil, errors.Errorf("type %+v is not a interface", ts.Type)
	}
	ft, ok := it.Methods.List[0].Type.(*ast.FuncType)
	if !ok {
		return nil, errors.Errorf("type %+v has no function", it)
	}
	var resultsList []*ast.Field
	if ft.Results != nil {
		resultsList = ft.Results.List
	}

	rtTypes := []*ast.Field{
		{
			Type: ast.NewIdent("bool"),
		},
	}

	var bodyStmt []ast.Stmt
	var ifbodyStmt []ast.Stmt
	var returnExprs []ast.Expr

	if len(resultsList) != 0 {
		var list []ast.Expr

		for _, r := range resultsList {
			rtTypes = append(rtTypes, &ast.Field{
				Type: r.Type,
			})
			bodyStmt = append(bodyStmt, &ast.DeclStmt{
				Decl: &ast.GenDecl{
					Tok: token.VAR,
					Specs: []ast.Spec{
						&ast.TypeSpec{
							Name: r.Names[0],
							Type: r.Type,
						},
					},
				},
			})
			list = append(list, r.Names[0])
			returnExprs = append(returnExprs, r.Names[0])
		}

		ifbodyStmt = append(ifbodyStmt, &ast.AssignStmt{
			Tok: token.ASSIGN,
			Lhs: list,
			Rhs: []ast.Expr{&ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("e"),
					Sel: it.Methods.List[0].Names[0],
				},
			}},
		})
	}

	ifresults := []ast.Expr{ast.NewIdent("true")}
	ifresults = append(ifresults, returnExprs...)
	ifbodyStmt = append(ifbodyStmt, &ast.ReturnStmt{
		Results: ifresults,
	})

	bodyStmt = append(bodyStmt, &ast.IfStmt{
		Init: &ast.AssignStmt{
			Lhs: []ast.Expr{
				ast.NewIdent("e"),
				ast.NewIdent("ok"),
			},
			Rhs: []ast.Expr{
				&ast.TypeAssertExpr{
					X:    ast.NewIdent("err"),
					Type: ts.Name,
				},
			},
			Tok: token.DEFINE,
		},
		Cond: ast.NewIdent("ok"),
		Body: &ast.BlockStmt{
			List: ifbodyStmt,
		},
	})

	bodyresults := []ast.Expr{ast.NewIdent("false")}
	bodyresults = append(bodyresults, returnExprs...)
	bodyStmt = append(bodyStmt, &ast.ReturnStmt{
		Results: bodyresults,
	})

	name := "Is" + strcase.ToCamel(ts.Name.Name)

	decls := []ast.Decl{
		&ast.FuncDecl{
			Name: ast.NewIdent(name),
			Type: &ast.FuncType{
				Params: &ast.FieldList{
					List: []*ast.Field{
						{
							Names: []*ast.Ident{ast.NewIdent("err")},
							Type:  ast.NewIdent("error"),
						},
					},
				},
				Results: &ast.FieldList{
					List: rtTypes,
				},
			},
			Body: &ast.BlockStmt{
				List: bodyStmt,
			},
		},
	}

	return decls, nil
}

func appendErrorImplementation(ts *ast.TypeSpec) ([]ast.Decl, error) {
	it, ok := ts.Type.(*ast.InterfaceType)
	if !ok {
		return nil, errors.Errorf("type %+v is not a interface", ts.Type)
	}
	_, ok = it.Methods.List[0].Type.(*ast.FuncType)
	if !ok {
		return nil, errors.Errorf("type %+v has no function", it)
	}

	var decls []ast.Decl
	name := strcase.ToCamel(ts.Name.Name)

	decls = append(decls, &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(name),
				Type: &ast.StructType{
					Fields: &ast.FieldList{},
				},
			},
		},
	})

	decls = append(decls, &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("e")},
					Type:  ast.NewIdent("*" + name),
				},
			},
		},
		Type: &ast.FuncType{
			Params:  &ast.FieldList{},
			Results: &ast.FieldList{},
		},
		Body: &ast.BlockStmt{},
		Name: ast.NewIdent(name),
	})

	decls = append(decls, &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("e")},
					Type:  ast.NewIdent("*" + name),
				},
			},
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: ast.NewIdent("string"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("fmt"),
								Sel: ast.NewIdent("Sprint"),
							},
							Args: []ast.Expr{
								ast.NewIdent(strconv.Quote(ts.Name.Name)),
							},
						},
					},
				},
			},
		},
		Name: ast.NewIdent("Error"),
	})

	return decls, nil
}
